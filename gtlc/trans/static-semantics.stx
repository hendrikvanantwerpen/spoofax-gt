module static-semantics

signature
  sorts ID = string
  
  sorts Program constructors
    Expr      : Expr -> Program
    ExprC     : ExprC -> Program
    Elaborate : Expr * ExprC -> Program
  
  sorts Type constructors
	BoolT : Type
	DynT  : Type
	FunT  : Type * Type -> Type  
	RefT  : Type -> Type

rules meet : Type * Type -> Type
  
  meet(BoolT(), BoolT()) = BoolT().
  
  meet(DynT(), T) = DynT().
  
  meet(T, DynT()) = DynT().
  
  meet(FunT(T11,T12), FunT(T21,T22)) = FunT(T1, T2) :-
    meet(T11,T21) == T1,
    meet(T12,T22) == T2.
    
  meet(RefT(T1), RefT(T2)) = RefT(S) :-
    meet(T1, T2) == S. // check 
    
rules consistent : Type * Type

  consistent(T1, T2) :- {S} meet(T1, T2) == S.
    
signature // core
  sorts ExprC constructors
	AscrC  : ExprC * Type -> ExprC
	CastC  : ExprC * Type * Type -> ExprC
    VarC   : ID -> ExprC
    TrueC  : ExprC
    FalseC : ExprC
    IfC    : ExprC * ExprC * ExprC -> ExprC
    AppC   : ExprC * ExprC -> ExprC
	LamC   : ID * Type * ExprC -> ExprC
	RefC   : ExprC -> ExprC
	DerefC : ExprC -> ExprC
	SetC   : ExprC * ExprC -> ExprC

rules programOK : Program
  
  programOK(ExprC(e)) :- {s T}
    new s,
    typeOfExprC(s, e) == T.
    
rules typeOfExprC : scope * ExprC -> Type

  typeOfExprC(s, VarC(x)) = T :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  typeOfExprC(s, TrueC()) = BoolT().
  
  typeOfExprC(s, FalseC()) = BoolT().
  
  typeOfExprC(s, IfC(e1,e2,e3)) = T :- {T1 T2 T3}
  	typeOfExprC(s, e1) == T1,
  	consistent(T1, BoolT()),
  	typeOfExprC(s, e2) == T2,
  	typeOfExprC(s, e3) == T3,
  	meet(T2, T3) == T.

  typeOfExprC(s, AppC(e1,e2)) = T :- {T1 T2}
    typeOfExprC(s, e1) == T1,
    typeOfExprC(s, e2) == T2,
    applicationYieldsC(T1, T2) == T.

  typeOfExprC(s, LamC(x,T1,e)) = FunT(T1,T2) :- {s_lam}
    new s_lam,
    typeOfExprC(s_lam,e) == T2,
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.
    
  typeOfExprC(s, AscrC(e,T)) = T :-
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, CastC(e,T1,T2)) = T :-
    typeOfExprC(s, e) == T.

rules applicationYieldsC : Type * Type -> Type
  
  applicationYieldsC(DynT(), T) = DynT().
  
  applicationYieldsC(FunT(T1,T2), T1') = T2 :-
    consistent(T1, T1').

signature // sugar
  sorts Expr constructors
	Ascr  : Expr * Type -> Expr
    Var   : ID -> Expr
    True  : Expr
    False : Expr
    If    : Expr * Expr * Expr -> Expr
    App   : Expr * Expr -> Expr
	Lam   : ID * Type * Expr -> Expr
	LamD  : ID * Expr -> Expr
	Ref   : Expr -> Expr
	Deref : Expr -> Expr
	Set   : Expr * Expr -> Expr
	
  namespaces
    Var : string
	
  relations  
    typeOfVar : occurrence -> Type

  name-resolution
    labels P
    
    resolve Var filter pathMatch[P*] min pathLt[$ < P]
  
rules 

  programOK(Expr(e1)) :- {s e2 T}
    new s,
    typeOfExpr(s, e1) == (e2, T).

  programOK(Elaborate(e1, AscrC(e2, T))) :- {s1 s2}
    new s1, new s2,
    typeOfExpr(s1, e1) == (e2, T),
    typeOfExprC(s2, e2) == T.

rules insertCasts : Program -> Program
  
  insertCasts(Expr(e1)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).
  
  insertCasts(Elaborate(e1, _)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).

rules typeOfExpr : scope * Expr -> ExprC * Type

  typeOfExpr(s, Var(x)) = (VarC(x), T) :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  typeOfExpr(s, True()) = (TrueC(), BoolT()).
  
  typeOfExpr(s, False()) = (FalseC(), BoolT()).
  
  typeOfExpr(s, If(e1,e2,e3)) = (IfC(e1',cast(e2',T2,T),cast(e3',T3,T)), T) :- {T1}
  	  typeOfExpr(s, e1) == (e1', T1),
  	  consistent(T1, BoolT()),
  	  typeOfExpr(s, e2) == (e2', T2),
  	  typeOfExpr(s, e3) == (e3', T3),
  	  meet(T2, T3) == T.

  typeOfExpr(s, App(e1,e2)) = (e,T) :- {e1' e2' T1 T2}
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2),
    applicationYields(e1', e2', T1, T2) == (e, T).

  typeOfExpr(s, Lam(x,T1,e)) = (LamC(x,T1,e'), FunT(T1,T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.

  typeOfExpr(s, LamD(x, e)) = 
    (LamC(x, DynT(), e'), FunT(DynT(), T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar DynT().
    
  typeOfExpr(s, Ascr(e,T)) = (e',T) :-
    typeOfExpr(s, e) == (e',T).
    
  typeOfExpr(s, Ref(e)) = (RefC(e'), RefT(T)) :- 
    typeOfExpr(s, e) == (e', T).
    
  typeOfExpr(s, Deref(e)) = (DerefC(e'), S) :- {T} // add some casting?
    typeOfExpr(s, e) == (e', T),
    consistent(T, RefT(S)).
   
   typeOfExpr(s, Set(e1, e2)) = (SetC(e1', e2'), T) :- {T1 T2 S} // add some casting?
     typeOfExpr(s, e1) == (e1', T1),
     consistent(T1, RefT(S)),
     typeOfExpr(s, e2) == (e2', T2).
     
    
rules applicationYields : ExprC * ExprC * Type * Type -> ExprC * Type
  
  applicationYields(e1, e2, DynT(), T) = (AppC(CastC(e1, DynT(), FunT(T,DynT())), e2), DynT()).
      
  applicationYields(e1, e2, FunT(T1, T2), T1') = (AppC(e1, cast(e2, T1', T1)), T2) :-
    consistent(T1', T1).
    
rules cast : ExprC * Type * Type -> ExprC
  
  cast(e, T, T) = e.
  
  cast(e, T1, T2) = CastC(e, T1, T2).
  
  