module static-semantics

signature
  sorts ID = string
  
  sorts Program constructors
    Expr      : Expr -> Program
    ExprC     : ExprC -> Program
    Elaborate : Expr * ExprC -> Program
  
  sorts Type constructors
    UnitT : Type
	BoolT : Type
	DynT  : Type
	FunT  : Type * Type -> Type  
	RefT  : Type -> Type

rules meet : Type * Type -> Type
  
  meet(BoolT(), BoolT()) = BoolT().
  
  meet(DynT(), T) = DynT().
  
  meet(T, DynT()) = DynT().
  
  meet(FunT(T11,T12), FunT(T21,T22)) = FunT(T1, T2) :-
    meet(T11,T21) == T1,
    meet(T12,T22) == T2.
    
  meet(RefT(T1), RefT(T2)) = RefT(S) :-
    meet(T1, T2) == S. // check // the rules here are tricky... see https://link.springer.com/chapter/10.1007/978-3-662-46669-8_18 
    
rules consistent : Type * Type

//  consistent(T1, T2) :- {S} meet(T1, T2) == S.
    
  consistent(BoolT(), BoolT()).
  
  consistent(DynT(), T).
  
  consistent(T, DynT()).
  
  consistent(FunT(T11,T12), FunT(T21,T22)) :-
    consistent(T11,T21),
    consistent(T12,T22).
    
  consistent(RefT(T1), RefT(T2)) :-
    consistent(T1, T2).
    
signature // core
  sorts ExprC constructors
	AscrC  : ExprC * Type -> ExprC
	CastC  : ExprC * Type * Type -> ExprC
    VarC   : ID -> ExprC
    UnitC  : ExprC
    TrueC  : ExprC
    FalseC : ExprC
    IfC    : ExprC * ExprC * ExprC -> ExprC
    AppC   : ExprC * ExprC -> ExprC
	LamC   : ID * Type * ExprC -> ExprC
	RefC   : ExprC -> ExprC
	DerefC : ExprC -> ExprC
	SetC   : ExprC * ExprC -> ExprC
	SeqC   : ExprC * ExprC -> ExprC
	LetC   : ID * Type * ExprC * ExprC -> ExprC

rules programOK : Program
  
  programOK(ExprC(e)) :- {s T}
    new s,
    typeOfExprC(s, e) == T.
    
rules typeOfExprC : scope * ExprC -> Type

  typeOfExprC(s, VarC(x)) = T :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  typeOfExprC(s, UnitC()) = UnitT().
  
  typeOfExprC(s, TrueC()) = BoolT().
  
  typeOfExprC(s, FalseC()) = BoolT().
  
  typeOfExprC(s, IfC(e1,e2,e3)) = T :- {T1 T2 T3}
  	typeOfExprC(s, e1) == T1,
  	consistent(T1, BoolT()),
  	typeOfExprC(s, e2) == T2,
  	typeOfExprC(s, e3) == T3,
  	meet(T2, T3) == T.

  typeOfExprC(s, AppC(e1,e2)) = T :- {T1 T2}
    typeOfExprC(s, e1) == T1,
    typeOfExprC(s, e2) == T2,
    applicationYieldsC(T1, T2) == T.

  typeOfExprC(s, LamC(x,T1,e)) = FunT(T1,T2) :- {s_lam}
    new s_lam,
    typeOfExprC(s_lam, e) == T2,
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.
    
  typeOfExprC(s, AscrC(e,T)) = T :-
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, CastC(e,T1,T2)) = T :-
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, RefC(e)) = RefT(T) :- 
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, DerefC(e)) = S :- {T} 
    typeOfExprC(s, e) == RefT(S).
   
   typeOfExprC(s, SetC(e1, e2)) = UnitT() :- {T}
     typeOfExprC(s, e1) == RefT(T),
     typeOfExprC(s, e2) == T.
     
   typeOfExprC(s, SeqC(e1, e2)) = T :- {S}
     typeOfExprC(s, e1) == S,
     typeOfExprC(s, e2) == T.
     
   typeOfExprC(s, LetC(x, T, e1, e2)) = S :- {s_let}
    typeOfExprC(s, e1) == T,
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T,
    typeOfExprC(s_let, e2) == S.
     

rules applicationYieldsC : Type * Type -> Type
  
  applicationYieldsC(DynT(), T) = DynT().
  
  applicationYieldsC(FunT(T1,T2), T1') = T2 :-
    consistent(T1, T1').

signature // sugar
  sorts Expr constructors
	Ascr  : Expr * Type -> Expr
    Var   : ID -> Expr
    Unit  : Expr
    True  : Expr
    False : Expr
    If    : Expr * Expr * Expr -> Expr
    App   : Expr * Expr -> Expr
	Lam   : ID * Type * Expr -> Expr
	LamD  : ID * Expr -> Expr
	Let   : ID * Type * Expr * Expr -> Expr
	LetD  : ID * Expr * Expr -> Expr
	Ref   : Expr -> Expr
	Deref : Expr -> Expr
	Set   : Expr * Expr -> Expr
	Seq   : Expr * Expr -> Expr
	
  namespaces
    Var : string
	
  relations  
    typeOfVar : occurrence -> Type

  name-resolution
    labels P
    
    resolve Var filter pathMatch[P*] min pathLt[$ < P]
  
rules 

  programOK(Expr(e1)) :- {s e2 T}
    new s,
    typeOfExpr(s, e1) == (e2, T).

  programOK(Elaborate(e1, AscrC(e2, T))) :- {s1 s2}
    new s1, new s2,
    typeOfExpr(s1, e1) == (e2, T),
    typeOfExprC(s2, e2) == T.

rules insertCasts : Program -> Program
  
  insertCasts(Expr(e1)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).
  
  insertCasts(Elaborate(e1, _)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).

rules typeOfExpr : scope * Expr -> ExprC * Type

  typeOfExpr(s, Ascr(e,T)) = (e',T) :-
    typeOfExpr(s, e) == (e',T).

  typeOfExpr(s, Var(x)) = (VarC(x), T) :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  typeOfExpr(s, Unit()) = (UnitC(), UnitT()).
  
  typeOfExpr(s, True()) = (TrueC(), BoolT()).
  
  typeOfExpr(s, False()) = (FalseC(), BoolT()).
  
  typeOfExpr(s, If(e1,e2,e3)) = 
    (IfC(cast(e1',T1,BoolT()),cast(e2',T2,T),cast(e3',T3,T)), T) 
    :-
  	  typeOfExpr(s, e1) == (e1', T1),
  	  typeOfExpr(s, e2) == (e2', T2),
  	  typeOfExpr(s, e3) == (e3', T3),
  	  meet(T2, T3) == T.

  typeOfExpr(s, App(e1,e2)) = (e,T) :- {e1' e2' T1 T2}
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2),
    app(e1', e2', T1, T2) == (e, T).

    rules app : ExprC * ExprC * Type * Type -> ExprC * Type
  
      app(e1, e2, DynT(), T) = (AppC(CastC(e1, DynT(), FunT(T, DynT())), e2), DynT()). // CApp1
      
      app(e1, e2, FunT(T1, T2), T1') = (AppC(e1, cast(e2, T1', T1)), T2) :- // CApp2 (when T1' != T1)/ CApp3
        consistent(T1', T1).

  typeOfExpr(s, Lam(x, T1, e)) = (LamC(x,T1,e'), FunT(T1,T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.

  typeOfExpr(s, LamD(x, e)) = (LamC(x, DynT(), e'), FunT(DynT(), T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar DynT().
    
  typeOfExpr(s, Let(x, T, e1, e2)) = (LetC(x, T, cast(e1', T1, T), e2'), S) :- {s_let}
    typeOfExpr(s, e1) == (e1', T1),
    consistent(T, T1),
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T,
    typeOfExpr(s_let, e2) == (e2', S).
       
  typeOfExpr(s, LetD(x, e1, e2)) = (LetC(x, t, cast(e1', T1, DynT()), e2'), S) :- {s_let}
    typeOfExpr(s, e1) == (e1', T1),
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar DynT(),
    typeOfExpr(s_let, e2) == (e2', S).
    
  typeOfExpr(s, Ref(e)) = (RefC(e'), RefT(T)) :- 
    typeOfExpr(s, e) == (e', T).
    
  typeOfExpr(s, Deref(e)) = (DerefC(cast(e', T, RefT(S))), S) :-
    typeOfExpr(s, e) == (e', T),
    deref(T) == S. 
    
    rules deref : Type -> Type   
      deref(DynT()) = DynT(). // CDeref1
      
      deref(RefT(T)) = T. // CDeref2
   
  // original rule returns the reference (?!) which is just ridiculous
  typeOfExpr(s, Set(e1, e2)) = (SetC(e1'', e2''), UnitT()) :- {T1 T2 e1' e2'}
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2),
    assign(e1', T1, e2', T2, e1'', e2'').
    
    rules assign : ExprC * Type * ExprC * Type -> ExprC * ExprC
      assign(e1', DynT(), e2', T) = (cast(e1', DynT(), RefT(T)), e2'). // CAssign1
        
      assign(e1', RefT(T), e2', S) = (e1', cast(e2', S, T)). // CAssign2 (when S!=T)/CAssign3   
     
  typeOfExpr(s, Seq(e1, e2)) = (SeqC(e1', e2'), T) :- {S}
    typeOfExpr(s, e1) == (e1', S),
    typeOfExpr(s, e2) == (e2', T). 
    
rules cast : ExprC * Type * Type -> ExprC
  
  cast(e, T, T) = e.

  cast(e, T1, T2) = CastC(e, T1, T2) :- consistent(T1, T2).

