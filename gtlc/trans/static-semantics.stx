module static-semantics

signature
  sorts ID = string
  
  sorts Program constructors
    Expr      : Expr -> Program
    ExprC     : ExprC -> Program
    Elaborate : Expr * ExprC -> Program
  
  sorts Type constructors
	Bool : Type
	Dyn  : Type
	Fun  : Type * Type -> Type  

rules meet : Type * Type -> Type
  
  meet(Bool(), Bool()) = Bool().
  
  meet(Dyn(), T) = Dyn().
  
  meet(T, Dyn()) = Dyn().
  
  meet(Fun(T11,T12), Fun(T21,T22)) = Fun(T1, T2) :-
    meet(T11,T21) == T1,
    meet(T12,T22) == T2.
    
rules consistent : Type * Type

  consistent(T1, T2) :- {S} meet(T1, T2) == S.
    
signature // core
  sorts ExprC constructors
    VarC   : ID -> ExprC
    TrueC  : ExprC
    FalseC : ExprC
    IfC    : ExprC * ExprC * ExprC -> ExprC
    AppC   : ExprC * ExprC -> ExprC
	LamC   : ID * Type * ExprC -> ExprC
	AscrC  : ExprC * Type -> ExprC
	CastC  : ExprC * Type * Type -> ExprC

rules programOK : Program
  
  programOK(ExprC(e)) :- {s T}
    new s,
    typeOfExprC(s, e) == T.
    
rules typeOfExprC : scope * ExprC -> Type

  typeOfExprC(s, VarC(x)) = T :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  typeOfExprC(s, TrueC()) = Bool().
  
  typeOfExprC(s, FalseC()) = Bool().
  
  typeOfExprC(s, IfC(e1,e2,e3)) = T :- {T1 T2 T3}
  	typeOfExprC(s, e1) == T1,
  	consistent(T1, Bool()),
  	typeOfExprC(s, e2) == T2,
  	typeOfExprC(s, e3) == T3,
  	meet(T2, T3) == T.

  typeOfExprC(s, AppC(e1,e2)) = T :- {T1 T2}
    typeOfExprC(s, e1) == T1,
    typeOfExprC(s, e2) == T2,
    applicationYieldsC(T1, T2) == T.

  typeOfExprC(s, LamC(x,T1,e)) = Fun(T1,T2) :- {s_lam}
    new s_lam,
    typeOfExprC(s_lam,e) == T2,
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.
    
  typeOfExprC(s, AscrC(e,T)) = T :-
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, CastC(e,T1,T2)) = T :-
    typeOfExprC(s, e) == T.

rules applicationYieldsC : Type * Type -> Type
  
  applicationYieldsC(Dyn(), T) = Dyn().
  
  applicationYieldsC(Fun(T1,T2), T1') = T2 :-
    consistent(T1, T1').

signature // sugar
  sorts Expr constructors
    Var   : ID -> Expr
    True  : Expr
    False : Expr
    If    : Expr * Expr * Expr -> Expr
    App   : Expr * Expr -> Expr
	Lam   : ID * Type * Expr -> Expr
	LamD  : ID * Expr -> Expr
	Ascr  : Expr * Type -> Expr
	
  namespaces
    Var : string
	
  relations  
    typeOfVar : occurrence -> Type

  name-resolution
    labels P
    
    resolve Var filter pathMatch[P*] min pathLt[$ < P]
  
rules 

  programOK(Expr(e1)) :- {s e2 T}
    new s,
    typeOfExpr(s, e1) == (e2, T).

  programOK(Elaborate(e1, AscrC(e2, T))) :- {s1 s2}
    new s1, new s2,
    typeOfExpr(s1, e1) == (e2, T),
    typeOfExprC(s2, e2) == T.

rules insertCasts : Program -> Program
  
  insertCasts(Expr(e1)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).
  
  insertCasts(Elaborate(e1, _)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).

rules typeOfExpr : scope * Expr -> ExprC * Type

  typeOfExpr(s, Var(x)) = (VarC(x), T) :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  typeOfExpr(s, True()) = (TrueC(), Bool()).
  
  typeOfExpr(s, False()) = (FalseC(), Bool()).
  
  typeOfExpr(s, If(e1,e2,e3)) = (IfC(e1',cast(e2',T2,T),cast(e3',T3,T)), T) :- {T1}
  	  typeOfExpr(s, e1) == (e1', T1),
  	  consistent(T1, Bool()),
  	  typeOfExpr(s, e2) == (e2', T2),
  	  typeOfExpr(s, e3) == (e3', T3),
  	  meet(T2, T3) == T.

  typeOfExpr(s, App(e1,e2)) = (e,T) :- {e1' e2' T1 T2}
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2),
    applicationYields(e1', e2', T1, T2) == (e, T).

  typeOfExpr(s, Lam(x,T1,e)) = (LamC(x,T1,e'), Fun(T1,T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.

  typeOfExpr(s, LamD(x, e)) = 
    (LamC(x, Dyn(), e'), Fun(Dyn(), T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar Dyn().
    
  typeOfExpr(s, Ascr(e,T)) = (e',T) :-
    typeOfExpr(s, e) == (e',T).
    
rules applicationYields : ExprC * ExprC * Type * Type -> ExprC * Type
  
  applicationYields(e1, e2, Dyn(), T) = (AppC(CastC(e1, Dyn(), Fun(T,Dyn)), e2), Dyn()).
      
  applicationYields(e1, e2, Fun(T1, T2), T1') = (AppC(e1, cast(e2, T1', T1)), T2) :-
    consistent(T1', T1).
    
rules cast : ExprC * Type * Type -> ExprC
  
  cast(e, T, T) = e.
  
  cast(e, T1, T2) = CastC(e, T1, T2).
  
  