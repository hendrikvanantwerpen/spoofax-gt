module static-semantics

signature
  sorts ID = string
  
  sorts Program constructors
    Expr      : Expr -> Program
    ExprC     : ExprC -> Program
    Elaborate : Expr * ExprC -> Program
    ExprV     : Expr * V -> Program
    ExprCV    : ExprC * V -> Program
  
  sorts V 
  
  sorts Type constructors
    UnitT : Type
	BoolT : Type
	PairT : Type * Type -> Type
	DynT  : Type
	FunT  : Type * Type -> Type  
	RefT  : Type -> Type

rules meet : Type * Type -> Type
  
  meet(UnitT(), UnitT()) = UnitT().
  
  meet(BoolT(), BoolT()) = BoolT().
  
  meet(DynT(), T) = DynT().
  
  meet(T, DynT()) = DynT().
  
  meet(PairT(T11, T12), PairT(T21, T22)) = PairT(T1, T2) :-
    meet(T11, T21) == T1,
    meet(T12, T22) == T2.
  
  meet(FunT(T11,T12), FunT(T21,T22)) = FunT(T1, T2) :-
    meet(T11,T21) == T1,
    meet(T12,T22) == T2.
    
  meet(RefT(T1), RefT(T2)) = RefT(S) :-
    meet(T1, T2) == S. // check // the rules here are tricky... see https://link.springer.com/chapter/10.1007/978-3-662-46669-8_18 
    
rules consistent : Type * Type

//  consistent(T1, T2) :- {S} meet(T1, T2) == S.
  
  consistent(UnitT(), UnitT()).
    
  consistent(BoolT(), BoolT()).
  
  consistent(DynT(), T).
  
  consistent(T, DynT()).
  
  consistent(PairT(T11, T12), PairT(T21, T22)) :-
    consistent(T11,T21),
    consistent(T12,T22).
  
  consistent(FunT(T11,T12), FunT(T21,T22)) :-
    consistent(T11,T21),
    consistent(T12,T22).
    
  consistent(RefT(T1), RefT(T2)) :-
    consistent(T1, T2).
    
signature // core
  sorts ExprC constructors
	AscrC   : ExprC * Type -> ExprC
	CastC   : ExprC * Type * Type -> ExprC
    VarC    : ID -> ExprC
    UnitC   : ExprC
    TrueC   : ExprC
    FalseC  : ExprC
    PairC   : ExprC * ExprC -> ExprC   
    FstC    : ExprC -> ExprC
    SndC    : ExprC -> ExprC 
    IsUnitC : ExprC -> ExprC
    IsBoolC : ExprC -> ExprC
    IsPairC : ExprC -> ExprC
    IsRefC  : ExprC -> ExprC
    IsFunC  : ExprC -> ExprC
    IfC     : ExprC * ExprC * ExprC -> ExprC
    AppC    : ExprC * ExprC -> ExprC
	LamC    : ID * Type * ExprC -> ExprC
	RefC    : ExprC -> ExprC
	DerefC  : ExprC -> ExprC
	SetC    : ExprC * ExprC -> ExprC
	SeqC    : ExprC * ExprC -> ExprC
	LetC    : ID * Type * ExprC * ExprC -> ExprC

rules programOK : Program
  
  programOK(ExprC(e)) :- {s T}
    new s,
    typeOfExprC(s, e) == T.
    
  programOK(ExprCV(e, v)) :- 
    programOK(ExprC(e)).
    
rules typeOfExprC : scope * ExprC -> Type
    
  typeOfExprC(s, AscrC(e,T)) = T :-
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, CastC(e,T1,T2)) = T2 :-
    typeOfExprC(s, e) == T1.
  
  typeOfExprC(s, UnitC()) = UnitT().
  
rules // booleans
  
  typeOfExprC(s, TrueC()) = BoolT().
  
  typeOfExprC(s, FalseC()) = BoolT().
  
  typeOfExprC(s, IfC(e1,e2,e3)) = T :-
  	typeOfExprC(s, e1) == BoolT(),
  	typeOfExprC(s, e2) == T,
  	typeOfExprC(s, e3) == T.
  
  // pairs 
  
  typeOfExprC(s, PairC(e1, e2)) = PairT(T1, T2) :-
    typeOfExprC(s, e1) == T1,
    typeOfExprC(s, e2) == T2.
    
  typeOfExprC(s, FstC(e)) = T1 :- {T2}
    typeOfExprC(s, e) == PairT(T1, T2).

  typeOfExprC(s, SndC(e)) = T2 :- {T1}
    typeOfExprC(s, e) == PairT(T1, T2).
  
  typeOfExprC(s, IsUnitC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
  typeOfExprC(s, IsBoolC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
  typeOfExprC(s, IsPairC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
  typeOfExprC(s, IsRefC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
  typeOfExprC(s, IsFunC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
    
rules // functions

  typeOfExprC(s, AppC(e1,e2)) = T2 :- {T1}
    typeOfExprC(s, e1) == FunT(T1,T2),
    typeOfExprC(s, e2) == T1.

  typeOfExprC(s, LamC(x,T1,e)) = FunT(T1,T2) :- {s_lam}
    new s_lam,
    typeOfExprC(s_lam, e) == T2,
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.
  
rules // bindings
     
   typeOfExprC(s, LetC(x, T1, e1, e2)) = T2 :- {s_let}
    typeOfExprC(s, e1) == T1,
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T1,
    typeOfExprC(s_let, e2) == T2.

  typeOfExprC(s, VarC(x)) = T :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
    
rules // references
    
  typeOfExprC(s, RefC(e)) = RefT(T) :- 
    typeOfExprC(s, e) == T.
    
  typeOfExprC(s, DerefC(e)) = T :-
    typeOfExprC(s, e) == RefT(T).
   
   typeOfExprC(s, SetC(e1, e2)) = UnitT() :- {T}
     typeOfExprC(s, e1) == RefT(T),
     typeOfExprC(s, e2) == T.
     
   typeOfExprC(s, SeqC(e1, e2)) = T :- {S}
     typeOfExprC(s, e1) == S,
     typeOfExprC(s, e2) == T.
     
signature // source
  sorts Expr constructors
	Ascr   : Expr * Type -> Expr
    Var    : ID -> Expr
    Unit   : Expr
    True   : Expr
    False  : Expr
    Pair   : Expr * Expr -> Expr
    Fst    : Expr -> Expr
    Snd    : Expr -> Expr
    IsUnit : Expr -> Expr
    IsBool : Expr -> Expr
    IsPair : Expr -> Expr
    IsRef  : Expr -> Expr
    IsFun  : Expr -> Expr
    If     : Expr * Expr * Expr -> Expr
    App    : Expr * Expr -> Expr
	Lam    : ID * Type * Expr -> Expr
	LamD   : ID * Expr -> Expr
	Let    : ID * Type * Expr * Expr -> Expr
	LetD   : ID * Expr * Expr -> Expr
	Ref    : Expr -> Expr
	Deref  : Expr -> Expr
	Set    : Expr * Expr -> Expr
	Seq    : Expr * Expr -> Expr
	
  namespaces
    Var : string
	
  relations  
    typeOfVar : occurrence -> Type

  name-resolution
    labels P
    
    resolve Var filter pathMatch[P*] min pathLt[$ < P]
  
rules 

  programOK(Expr(e1)) :- {s e2 T}
    new s,
    typeOfExpr(s, e1) == (e2, T).

  programOK(Elaborate(e1, AscrC(e2, T))) :- {s1 s2}
    new s1, new s2,
    typeOfExpr(s1, e1) == (e2, T),
    typeOfExprC(s2, e2) == T.
  
  programOK(ExprV(e, v)) :- 
    programOK(Expr(e)).

rules insertCasts : Program -> Program
  
  insertCasts(Expr(e1)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).
  
  insertCasts(ExprV(e1, v)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).
  
  insertCasts(Elaborate(e1, _)) = Elaborate(e1, AscrC(e2, T)) :- {s}
    new s,
    typeOfExpr(s, e1) == (e2, T).

rules cast : ExprC * Type * Type -> ExprC
  
  cast(e, T, T) = e.

  cast(e, T1, T2) = CastC(e, T1, T2) :- consistent(T1, T2).
  
rules typeOfExpr : scope * Expr -> ExprC * Type

  typeOfExpr(s, Ascr(e,T)) = (cast(e',T',T),T) :-
    typeOfExpr(s, e) == (e',T').
  
  typeOfExpr(s, Unit()) = (UnitC(), UnitT()).
  
  // booleans
  
  typeOfExpr(s, True()) = (TrueC(), BoolT()).
  
  typeOfExpr(s, False()) = (FalseC(), BoolT()).
  
  typeOfExpr(s, If(e1,e2,e3)) = 
    (IfC(cast(e1',T1,BoolT()),cast(e2',T2,T),cast(e3',T3,T)), T) 
    :-
  	  typeOfExpr(s, e1) == (e1', T1),
  	  typeOfExpr(s, e2) == (e2', T2),
  	  typeOfExpr(s, e3) == (e3', T3),
  	  meet(T2, T3) == T.
  	 
  // pairs

  typeOfExpr(s, Pair(e1, e2)) = (PairC(e1', e2'), PairT(T1, T2)) :-
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2).
  
  typeOfExpr(s, Fst(e)) = (FstC(e''), T1) :- {e' T}
    typeOfExpr(s, e) == (e', T),
    fst(e', T) == (e'', T1).
    
    rules fst : ExprC * Type -> ExprC * Type
      fst(e, DynT()) = (cast(e, DynT(), PairT(DynT(), DynT())), DynT()).
      fst(e, PairT(T1, T2)) = (e, T1).
 
   typeOfExpr(s, Snd(e)) = (SndC(e''), T2) :- {e' T}
    typeOfExpr(s, e) == (e', T),
    snd(e', T) == (e'', T2).
    
    rules snd : ExprC * Type -> ExprC * Type
      snd(e, DynT()) = (cast(e, DynT(), PairT(DynT(), DynT())), DynT()).
      snd(e, PairT(T1, T2)) = (e, T2).   

  typeOfExpr(s, IsUnit(e)) = (IsUnitC(cast(e', T, DynT())), BoolT()) :-
    typeOfExpr(s, e) == (e', T).
  typeOfExpr(s, IsBool(e)) = (IsBoolC(cast(e', T, DynT())), BoolT()) :-
    typeOfExpr(s, e) == (e', T).
  typeOfExpr(s, IsPair(e)) = (IsPairC(cast(e', T, DynT())), BoolT()) :-
    typeOfExpr(s, e) == (e', T).
  typeOfExpr(s, IsRef(e)) = (IsRefC(cast(e', T, DynT())), BoolT()) :-
    typeOfExpr(s, e) == (e', T).
  typeOfExpr(s, IsFun(e)) = (IsFunC(cast(e', T, DynT())), BoolT()) :-
    typeOfExpr(s, e) == (e', T).
        
  // bindings
        
  typeOfExpr(s, Var(x)) = (VarC(x), T) :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].

  typeOfExpr(s, Lam(x, T1, e)) = (LamC(x,T1,e'), FunT(T1,T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.
    
  typeOfExpr(s, Let(x, T, e1, e2)) = (LetC(x, T, cast(e1', T1, T), e2'), S) :- {s_let}
    typeOfExpr(s, e1) == (e1', T1),
    consistent(T, T1),
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T,
    typeOfExpr(s_let, e2) == (e2', S).
       
  typeOfExpr(s, LetD(x, e1, e2)) = (LetC(x, T1, e1', e2'), S) :- {s_let}
    typeOfExpr(s, e1) == (e1', T1),
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T1,
    typeOfExpr(s_let, e2) == (e2', S).

  // functions

  typeOfExpr(s, LamD(x, e)) = (LamC(x, DynT(), e'), FunT(DynT(), T2)) :- {s_lam}
    new s_lam,
    typeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar DynT().
    
  typeOfExpr(s, App(e1,e2)) = (e,T) :- {e1' e2' T1 T2}
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2),
    app(e1', e2', T1, T2) == (e, T).

    rules app : ExprC * ExprC * Type * Type -> ExprC * Type
  
      app(e1, e2, DynT(), T) = (AppC(CastC(e1, DynT(), FunT(T, DynT())), e2), DynT()). // CApp1
      
      app(e1, e2, FunT(T1, T2), T1') = (AppC(e1, cast(e2, T1', T1)), T2) :- // CApp2 (when T1' != T1)/ CApp3
        consistent(T1', T1).
    
  // references
  
  typeOfExpr(s, Ref(e)) = (RefC(e'), RefT(T)) :- 
    typeOfExpr(s, e) == (e', T).
    
  typeOfExpr(s, Deref(e)) = (DerefC(cast(e', T, RefT(S))), S) :-
    typeOfExpr(s, e) == (e', T),
    deref(T) == S. 
    
    rules deref : Type -> Type   
      deref(DynT()) = DynT(). // CDeref1
      
      deref(RefT(T)) = T. // CDeref2
   
  // original rule returns the reference (?!) which is just ridiculous
  typeOfExpr(s, Set(e1, e2)) = (SetC(e1'', e2''), UnitT()) :- {T1 T2 e1' e2'}
    typeOfExpr(s, e1) == (e1', T1),
    typeOfExpr(s, e2) == (e2', T2),
    assign(e1', T1, e2', T2, e1'', e2'').
    
    rules assign : ExprC * Type * ExprC * Type -> ExprC * ExprC
      assign(e1', DynT(), e2', T) = (cast(e1', DynT(), RefT(T)), e2'). // CAssign1
        
      assign(e1', RefT(T), e2', S) = (e1', cast(e2', S, T)). // CAssign2 (when S!=T)/CAssign3   
     
  // sequential composition
  
  typeOfExpr(s, Seq(e1, e2)) = (SeqC(e1', e2'), T) :- {S}
    typeOfExpr(s, e1) == (e1', S),
    typeOfExpr(s, e2) == (e2', T). 

rules thatteSubtype : Type * Type

  thatteSubtype(T, DynT()).
  
  thatteSubtype(FunT(T11,T12), FunT(T21, T22)) :-
    thatteSubtype(T21, T11),
    thatteSubtype(T12, T22).
    
rules thatteLUB : Type * Type -> Type
rules thatteGLB : Type * Type -> Type

  thatteLUB(T, DynT()) = T.
  thatteLUB(DynT(), T) = T.

  thatteLUB(UnitT(), UnitT()) = UnitT().
  thatteLUB(BoolT(), BoolT()) = BoolT().

  thatteLUB(PairT(T11, T12), PairT(T21, T22)) = PairT(T1, T2) :-
    thatteLUB(T11, T21) == T1,
    thatteLUB(T12, T22) == T2.
    
  thatteLUB(FunT(T11,T12), FunT(T21,T22)) = FunT(T1, T2) :-
    thatteGLB(T11,T21) == T1,
    thatteLUB(T12,T22) == T2.
    
  thatteGLB(T, DynT()) = DynT().
  thatteGLB(DynT(), T) = DynT().

  thatteGLB(UnitT(), UnitT()) = UnitT().
  thatteGLB(BoolT(), BoolT()) = BoolT().

  thatteGLB(PairT(T11, T12), PairT(T21, T22)) = PairT(T1, T2) :-
    thatteGLB(T11, T21) == T1,
    thatteGLB(T12, T22) == T2.
    
  thatteGLB(FunT(T11,T12), FunT(T21,T22)) = FunT(T1, T2) :-
    thatteLUB(T11,T21) == T1,
    thatteGLB(T12,T22) == T2.
  
  // TODO what do to for refs? isovariant?
  
rules thatteCast : ExprC * Type * Type -> ExprC

  thatteCast(e, T, T) = e.
  
  thatteCast(e, T1, T2) = CastC(CastC(e, T1, Tglb), Tglb, T2) :-
    thatteGLB(T1, T2) == Tglb.
  
rules thatteTypeOfExpr : scope * Expr -> ExprC * Type

  rules // base values

  thatteTypeOfExpr(s, Unit()) = (UnitC(), UnitT()).
  
  thatteTypeOfExpr(s, True()) = (TrueC(), BoolT()).
  thatteTypeOfExpr(s, False()) = (FalseC(), BoolT()).
  
  rules // variables and binding
  
  thatteTypeOfExpr(s, Var(x)) = (VarC(x), T) :- {p d}
    typeOfVar of Var{x@x} in s |-> [(p, (d, T))].
  
  thatteTypeOfExpr(s, Let(x, T, e1, e2)) = (LetC(x, T, cast(e1', T1, T), e2'), S) :- {s_let}
    thatteTypeOfExpr(s, e1) == (e1', T1),
    consistent(T, T1),
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T,
    thatteTypeOfExpr(s_let, e2) == (e2', S).
       
  thatteTypeOfExpr(s, LetD(x, e1, e2)) = (LetC(x, T1, e1', e2'), S) :- {s_let}
    thatteTypeOfExpr(s, e1) == (e1', T1),
    new s_let,
    s_let -P-> s,
    s_let -> Var{x@x} with typeOfVar T1,
    thatteTypeOfExpr(s_let, e2) == (e2', S).
  
  rules // functions
  
  thatteTypeOfExpr(s, Lam(x, T1, e)) = (LamC(x,T1,e'), FunT(T1,T2)) :- {s_lam}
    new s_lam,
    thatteTypeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar T1.

  // TODO: Oliart's type inference can guess types other than ?
  thatteTypeOfExpr(s, LamD(x, e)) = (LamC(x, DynT(), e'), FunT(DynT(), T2)) :- {s_lam}
    new s_lam,
    thatteTypeOfExpr(s_lam, e) == (e', T2),
    s_lam -P-> s,
    s_lam -> Var{x@x} with typeOfVar DynT().
  
  thatteTypeOfExpr(s, App(e1,e2)) = (e,T) :- {e1' e2' T1 T2}
    thatteTypeOfExpr(s, e1) == (e1', T1),
    thatteTypeOfExpr(s, e2) == (e2', T2),
    thatteApp(e1', e2', T1, T2) == (e, T).

    rules thatteApp : ExprC * ExprC * Type * Type -> ExprC * Type
  
      thatteApp(e1, e2, DynT(), T) = (AppC(CastC(e1, DynT(), FunT(T, DynT())), e2), DynT()). 
      
      thatteApp(e1, e2, FunT(T1, T2), T3) = (AppC(e1, thatteCast(e2, T3, T1)), T2).
  
  // TODO Ascr, If, Pair, Fst, Snd, Is*, Ref, Deref, Set, Seq
  