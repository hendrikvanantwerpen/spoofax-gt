module static-semantics

imports statics/core/base
imports statics/core/fun
imports statics/core/bool 
imports statics/core/unit 
imports statics/core/num
imports statics/core/pair
imports statics/core/ref
imports statics/core/cast
imports statics/core/dyn
imports statics/core/ascr

imports statics/source/base
imports statics/source/fun
imports statics/source/bool 
imports statics/source/unit 
imports statics/source/num
imports statics/source/pair
imports statics/source/ref
imports statics/source/cast
imports statics/source/dyn
imports statics/source/ascr

imports statics/mode

signature
  
  sorts Program constructors
    Expr      : ModedExpr -> Program
    Elaborate : ModedExpr * ExprC -> Program
    ExprV     : ExprC * V -> Program

  sorts ModedExpr constructors
    Moded   : Mode * Expr -> ModedExpr
    Default :        Expr -> ModedExpr
   
  sorts V  

//  consistent(T1, T2) :- {S} meet(T1, T2) == S.
  
signature // core
  constructors
    IsUnitC : ExprC -> ExprC
    IsIntC  : ExprC -> ExprC
    IsRefC  : ExprC -> ExprC
    IsFunC  : ExprC -> ExprC

rules // type reflection
  
  typeOfExprC(s, IsUnitC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
    
  typeOfExprC(s, IsBoolC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
    
  typeOfExprC(s, IsIntC(e)) = IntT() :-
    typeOfExprC(s, e) == DynT().
    
  typeOfExprC(s, IsRefC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
    
  typeOfExprC(s, IsFunC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
    
  typeOfExprC(s, IsPairC(e)) = BoolT() :-
    typeOfExprC(s, e) == DynT().
    
signature // source
  sorts Expr constructors
    Core   : ExprC -> Expr
    IsUnit : Expr -> Expr
    IsBool : Expr -> Expr
    IsInt  : Expr -> Expr
    IsPair : Expr -> Expr
    IsRef  : Expr -> Expr
    IsFun  : Expr -> Expr
	
rules modeAndExpr : ModedExpr -> (Mode * Expr)

  modeAndExpr(Moded(m,e)) = (m,e).
  
  modeAndExpr(Default(e)) = (GT(),e).
  
rules programOK : Program // elaboration

  programOK(Expr(me)) :- {s m e1 e2 T}
    modeAndExpr(me) == (m,e1),
    new s,
    typeOfExpr(m, s, e1) == (e2, T).

  programOK(Elaborate(me, AscrC(e2, T))) :- {m e1 s1 s2}
    modeAndExpr(me) == (m,e1),
    new s1, new s2,
    typeOfExpr(m, s1, e1) == (e2, T),
    typeOfExprC(s2, e2) == T.
  
  programOK(ExprV(ec, v)) :- {s T}
    new s,
    typeOfExprC(s, ec) == T. // TODO check the value is well typed?

rules insertCasts : Program -> Program 
  
  insertCasts(Expr(me1)) = Elaborate(Moded(m,e1), AscrC(e2, T)) :- {s}
    modeAndExpr(me1) == (m,e1),
    new s,
    typeOfExpr(m, s, e1) == (e2, T).
  
  insertCasts(ExprV(ec, v)) = ExprV(ec, v) :- {s T}
    new s,
    typeOfExprC(s, ec) == T.
  
  insertCasts(Elaborate(me1, _)) = Elaborate(Moded(m, e1), AscrC(e2, T)) :- {s}
    modeAndExpr(me1) == (m,e1),
    new s,
    typeOfExpr(m, s, e1) == (e2, T).

rules 

  typeOfExpr(m, s, Core(ec)) = (ec,T) :-
    typeOfExprC(s, ec) == T.

rules
  
  typeOfExpr(m, s, IsUnit(e)) = (IsUnitC(cast(m, e', T, DynT())), BoolT()) :-
    typeOfExpr(m, s, e) == (e', T).
  typeOfExpr(m, s, IsBool(e)) = (IsBoolC(cast(m, e', T, DynT())), BoolT()) :-
    typeOfExpr(m, s, e) == (e', T).
  typeOfExpr(m, s, IsInt(e)) = (IsIntC(cast(m, e', T, DynT())), BoolT()) :-
    typeOfExpr(m, s, e) == (e', T).
  typeOfExpr(m, s, IsPair(e)) = (IsPairC(cast(m, e', T, DynT())), BoolT()) :-
    typeOfExpr(m, s, e) == (e', T).
  typeOfExpr(m, s, IsRef(e)) = (IsRefC(cast(m, e', T, DynT())), BoolT()) :-
    typeOfExpr(m, s, e) == (e', T).
  typeOfExpr(m, s, IsFun(e)) = (IsFunC(cast(m, e', T, DynT())), BoolT()) :-
    typeOfExpr(m, s, e) == (e', T).
                
 
